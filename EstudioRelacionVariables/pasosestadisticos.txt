En primer lugar vamosa estudiar la relacion entre variables iguales. Es decir, predictores que surgen de distintas bases de ddatos y deberian tener una relacion lineal perfecta
pero que por venir de distintas fuentes pueden ser ligeramente distintas. Para ello creamos una función, ya que la utilizaremos varias veces con os disintos grupos de variables
es la funcion estudia_coeficientes

Con pvalor<<< 0.05, rechazamos hipotesis nula, no podemos rechazar que las variables estén relacionadas.

Para ello empezamos estudiando al relacion lineal por medio del coef de correlacion de pearson.
Tambien estudiamos a la vez la correlacion no lineal de Spearman  y la covarianza
 Hay que eliminar valores nulos para poder calcular las correlaciones.
Cuando dos variables esten correlacionadas una se empleara para rellenar la otra,
y la resultante se compara con el resto de variables del grupo, hasta generar una vriable que contenga todo elg rupo.Se van rellenando de 
variables con mayor correlacion a menor
Las variables qeu se estudian entre si dos a dos son(En mayuscula se indica el nombre de la variable que contiene el grupo):

FRECUENCIA POBLACIONAL:
maf
gnomAD_genome_ALL	
1000g2015aug_all
1000G_ALL
ExAC_ALL
AF
PopFreqMax
5000Exomes

A partir de la definición pareciese evidente que el maf se relacione con la frecuencia poblacional, sin embargo esto no ocurre así y la relación 
según los coef es muy baja.
A partir de los coeficientes podemos determinar que maf se relaciona con 5000exomes, y el resto de frecuencias entre si. Todo con un relacion lineal positiva.
Para entrenar el modelo empleamos un cross_validation.
Así, realizamos una regresión lineal para rellenar valores nan empezando pr las relaciones más altas. Así acabamos generando la variable "POBLACION_t",
con la resultante de las variables de poblacion y "FRECUENCIA_t" con la resultante de maf + 5000Exomes

maf + 5000E: 
Usamos 5000e para predecir los nan de maf. 
El coef de regresion es 0.912, por lo que hay bastante relación y se puede usar para predecir la otra.
Realizamos un crossvalidation en 10 partes
El MSE indica que el valor de equivocación de la predicción es bastante pequeño, por lo que la prdicción parece acertada y que la equivocación se rleva al tercer decimal

1000G_ALL + 1000g2015aug_all;  + gnomAD_genome_ALL; + AF; + ExAC_ALL; + PopFreqMax :
En este caso el empleo del modelo de regresión para relenar nan en 1000G_ALL logra una variable final POLACION_t que apenas tiene nan en comparación con la situación inicial.
La forma de hacerlo se basa en rellenar primero a partir de las variables con mayor coef de pearson
--

PREDICTORES:
'SIFT_score', 'sift',  'ljb23_sift',
'Polyphen2_HDIV_score', 'Polyphen2_HVAR_score', 'polyphen', 
'MutationTaster_score', 
'PROVEAN_score', 
'CADD_phred', 
'phyloP20way_mammalian', 'phylop',
'SiPhy_29way_logOdds', 
'FATHMM_score','FATHMM',
'grantham'

A raiz de los predictores establecemos que lo más sensato es generar varias variables. Aunque esta idea podría parecer originalmente la mas acertada una vez expuesta, los
predictores se obtienen a partir de las variantes, por lo que su relación debería ser en origen mucho más significativa, ya que obtienen sus vaores sobre os mismos datos de entrada,
sin embargo, bien por que a base de datos de la que procede cada predictor sea erronea (o desactualizada) o porque en si mismos los predictores estén realmente menos relacionados de lo que sugieren,
lo cierto es que los coeficientes de correlación de las variables, los situan mucho más alejados que las relaciones existentes en el grupo anterior.Además se observa que variables no relacionadas
linealmente tampoco lo estarian acuediendo a un modelo no lineal.
El caso mas curioso lo componen las variables FATHMM y FTHMM_Score, pues mientras la segunda se relaciona linealmente con el phylop (con un coeficiente no muy alto, 
pero un pvalor significativo ~ 0) la segunda no presenta un coeficiente elevado de relación con las demás y constituye en si misma una variable independiente. Sin embargo, 
y dado que la significancia de la relacion negativa de estas dos variables es es grande (pvalor ~9.192622145079578e-271), emplearemos una para rellenar los valores nan de la otra
y posteriormente la resultante de ambas para rellenar los de phylop


Estandarizamos la columna provean. [-14,+14], CADD [0, 99], phylop [-20 , 30], grantham [5, 215]
Las columnas 'SIFT_score', 'sift','ljb23_sift','Polyphen2_HDIV_score', 'Polyphen2_HVAR_score', 'polyphen','phyloP20way_mammalian','phylop',
           'MutationTaster_score', 'PROVEAN_score', 'CADD_phred', 'FATHMM','grantham'
ya tienen rangos [0, 1]

Las columnas phyloP20way_mammalian, SiPhy_29way_logOdds, FATHMM_score no tienen un rango determinado, 
por lo que no deberíamos estandarizar esos datos y constituirán vriables en si mismas.
Resulta muy extraño que la relación entre FATHMM y FATHMM_score es muy muy pequeña, posibemente por el hecho de que una está estandarizada y 
la otra no tiene límite superior. Aunque supuestamente on preictores equivalentes, desconozco la razón de esta diferencia entre las bases de datos empleadas para anotar.

Tras el estudio de las correlaciones, se determina que las relaciones para rellenar nan serán:
SIFT_t:[SIFT_score <- sift <- 	 ljb23_sift] (modelo r.lineal) <- PROVEAN (modelo r. logarítmica)
POLYPHEN_t :polyphen <- Polyphen2_HDIV_score <- Polyphen2_HVAR_score <- CADD_phred
PHYLOP_t:phylop <- phyloP20way_mammalian	<- [ FATHMM <- FATHMM_score] <- SiPhy_29way_logOdds

Ojo, PROVEAN lo metemos con modelo reg logaritmica xq no teine buen coef de pearson pero sí de spearman, lo que implica que son multilineares, no linares

--
En el caso de las variables ordinales, y según la definición de los propios coeficientes, se puede aplicar igualmente, 
pero los modelos empleados para rellenar los nan deben ser de clasificación y no de predicción, por loq eu empleamos la regresión logística


'Func.refGene', 'ExonicFunc.refGene', 'function', 'clinvar',

Tan solo vemos una fuerte correlacion entre ExonicFunc.refGene y function. generamos FUNCTION_t a partir de ambas


#######################



Como las cariantes son pocas, los eventos positivos (categoria 1) son muy pequeños y a la hora de hacer las particiones de test y entrenamiento, encontraremos muy pocos ventos de este tipo entre los datos,
por ello vamos a emplear SMOTE para generar más variables de este tipo
















